// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.  

package frc.robot.subsystems; 


import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Constants.DriveTrainConstants;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;
//import edu.wpi.first.math.kinematics.SwerveDriveKinematics;

//import edu.wpi.first.wpilibj.ADIS16470_IMU;
import com.analog.adis16470.frc.ADIS16470_IMU;
//TODO want one with built in gyro so can caste so change to com.analog.adis16470.frc.ADIS16470_IMU 
// which can be found in github https://github.com/juchong/ADIS16470-RoboRIO-Driver/blob/master/java/src/main/java/com/analog/adis16470/frc/ADIS16470_IMU.java
// perhapes we need to do vendor install
//import edu.wpi.first.wpilibj.CAN;
import edu.wpi.first.wpilibj.interfaces.Gyro;



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax cANSparkMAXleft1;
private CANSparkMax cANSparkMAXleft2;
private MotorControllerGroup driveTrainGroupLeft;
private CANSparkMax cANSparkMAXright1;
private CANSparkMax cANSparkMAXright2;
private MotorControllerGroup driveTrainGroupRight;
private DifferentialDrive differentialDrive1;
private RelativeEncoder m_encoderLeft;
private RelativeEncoder m_encoderRight;
private ADIS16470_IMU m_Gyro;
private final DifferentialDriveOdometry m_odometry;
private CANSparkMax cANSparkMAXleft3;
private CANSparkMax cANSparkMAXright3;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
    *
    */
    public DriveTrain() {
    m_Gyro = new ADIS16470_IMU(); 
    m_Gyro.reset();
    m_Gyro.calibrate();

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
cANSparkMAXleft1 = new CANSparkMax(19, MotorType.kBrushless);
cANSparkMAXleft1.setInverted(false); 
cANSparkMAXleft1.setSmartCurrentLimit(Constants.DriveTrainConstants.SparkMaxCurrentLimit);
 
cANSparkMAXleft2 = new CANSparkMax(18, MotorType.kBrushless);
cANSparkMAXleft2.setInverted(false); 
cANSparkMAXleft2.setSmartCurrentLimit(Constants.DriveTrainConstants.SparkMaxCurrentLimit);

cANSparkMAXleft3 = new CANSparkMax(17, MotorType.kBrushless);
cANSparkMAXleft3.setInverted(false); 
cANSparkMAXleft3.setSmartCurrentLimit(Constants.DriveTrainConstants.SparkMaxCurrentLimit);
 
 

/**driveTrainLeft = new PWMSparkMax(0);
 addChild("DriveTrainLeft",driveTrainLeft);
 driveTrainLeft.setInverted(true);

driveTrainLeft2 = new PWMSparkMax(2);
 addChild("DriveTrainLeft2",driveTrainLeft2);
 driveTrainLeft2.setInverted(true);
*/
driveTrainGroupLeft = new MotorControllerGroup(cANSparkMAXleft1, cANSparkMAXleft2, cANSparkMAXleft3);
 addChild("DriveTrainGroupLeft",driveTrainGroupLeft);
 

cANSparkMAXright1 = new CANSparkMax(20, MotorType.kBrushless);
cANSparkMAXright1.setInverted(true);
cANSparkMAXright1.setSmartCurrentLimit(Constants.DriveTrainConstants.SparkMaxCurrentLimit);

cANSparkMAXright2 = new CANSparkMax(1, MotorType.kBrushless);
cANSparkMAXright2.setInverted(true); 
cANSparkMAXright2.setSmartCurrentLimit(Constants.DriveTrainConstants.SparkMaxCurrentLimit);

cANSparkMAXright3 = new CANSparkMax(2, MotorType.kBrushless);
cANSparkMAXright3.setInverted(true); 
cANSparkMAXright3.setSmartCurrentLimit(Constants.DriveTrainConstants.SparkMaxCurrentLimit);

/*driveTrainRight = new PWMSparkMax(1);
 addChild("DriveTrainRight",driveTrainRight);
 driveTrainRight.setInverted(false);

driveTrainRight2 = new PWMSparkMax(3);
 addChild("DriveTrainRight2",driveTrainRight2);
 driveTrainRight2.setInverted(false);
*/
driveTrainGroupRight = new MotorControllerGroup(cANSparkMAXright1, cANSparkMAXright2, cANSparkMAXright3);
 addChild("DriveTrainGroupRight",driveTrainGroupRight);
 
// 
//differentialDrive1 = new DifferentialDrive (driveTrainGroupRight, driveTrainGroupLeft);// note left and right in wrong order so the robot responds correctly (turning left when joystick is pushed left)
 //addChild("Differential Drive 1",differentialDrive1);
//SwerveDriveKinematics
// differentialDrive1.
// differentialDrive1.setSafetyEnabled(true);
//differentialDrive1.setExpiration(0.1);
//differentialDrive1.setMaxOutput(1.0);



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    // Encoder object created to display position values
    m_encoderLeft  = cANSparkMAXleft1.getEncoder();
    // position by default provides nmber of rotations, gearboxratio 
    double gearBoxRatio = Constants.DriveTrainConstants.kGearRatio;
    double wheelDiameter = 6; // 6 inches
    double wheelCircumference = wheelDiameter * java.lang.Math.PI;
    double convertOneMotorRotationToInches = wheelCircumference/gearBoxRatio;
    //m_encoderLeft.setPositionConversionFactor(convertOneMotorRotationToInches);
    m_encoderLeft.setPositionConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor);
    m_encoderLeft.setVelocityConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor/60);
    //m_encoderLeft.setInverted(true);
    //Encoder starts in RPM, we need to get to inches/sec
    double convertMinToSeconds = 60;//converts RPM (Rev/min) to Rev/sec
    double convertOneRPMtoInPerSec = convertOneMotorRotationToInches/convertMinToSeconds;
    m_encoderLeft.setVelocityConversionFactor(convertOneRPMtoInPerSec);

    m_encoderRight = cANSparkMAXright1.getEncoder();
    //m_encoderRight.setPositionConversionFactor(convertOneMotorRotationToInches);
    m_encoderRight.setPositionConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor);
    m_encoderRight.setVelocityConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor/60);
    m_encoderRight.setVelocityConversionFactor(convertOneRPMtoInPerSec);
    //m_encoderRight.setInverted(true);

   resetEncoders();

 m_odometry = new DifferentialDriveOdometry(Rotation2d.fromDegrees(m_Gyro.getAngle()),0,0);
 m_odometry.resetPosition(Rotation2d.fromDegrees(m_Gyro.getAngle()), m_encoderLeft.getPosition(), m_encoderRight.getPosition(), new Pose2d());


    //NOTE IF CONVERSION SETTINGS NOT WORKING, Remove this if they do work.
    //2021 Cheif Delphi commentary say to get conversionfactor  to work need to burn settings:
    // from:https://www.chiefdelphi.com/t/spark-max-encoder-setpositionconversionfactor-not-doing-anything/396629/17
    // Burn settings into Spark MAX flash
    //leftMotor1.burnFlash();
    }
    
    public void resetEncoders(){
     m_encoderRight.setPosition(0);
     m_encoderLeft.setPosition(0);
}

    public void setBreakMode(){
        cANSparkMAXleft1.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kBrake);
        cANSparkMAXleft2.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kBrake);
        cANSparkMAXright1.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kBrake);
        cANSparkMAXright2.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kBrake);
    } 

    public void setCoastMode() {
    cANSparkMAXleft1.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kCoast);
    cANSparkMAXleft2.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kCoast);
    cANSparkMAXright1.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kCoast);
    cANSparkMAXright2.setIdleMode(com.revrobotics.CANSparkBase.IdleMode.kCoast);
    }

    public double getRightEncoderPosition(){
        return m_encoderRight.getPosition();
    }

    public double getRightEncoderVelocity(){
        return m_encoderRight.getVelocity();
    }

    public double getLeftEncoderPosition(){
        return m_encoderLeft.getPosition();
    }

    public double getLeftEncoderVelocity(){
        return m_encoderLeft.getVelocity();
    }

    public double getSpeed(){
        return(getLeftEncoderVelocity()+getRightEncoderVelocity())/2;
    }

    public double getHeading(){
        return m_Gyro.getAngle();
    }
    public double getTurnRate(){
        return -m_Gyro.getRate();
    }

    public Pose2d getPose(){
        return m_odometry.getPoseMeters();
    }

    public void resetOdometry(Pose2d pose){
        resetEncoders();
        m_odometry.resetPosition(Rotation2d.fromDegrees(m_Gyro.getAngle()), m_encoderLeft.getPosition(), m_encoderRight.getPosition(), pose);
    }

    public DifferentialDriveWheelSpeeds getWheelSpeeds(){
        return new DifferentialDriveWheelSpeeds(getLeftEncoderVelocity(), getRightEncoderVelocity());
    }


    public void tankDriveVolts(double leftVolts, double rightVolts){
        driveTrainGroupLeft.setVoltage(leftVolts); 
        driveTrainGroupRight.setVoltage(rightVolts);
        differentialDrive1.feed();
    }

    public double getAverageEncoderDistance(){
        return (getLeftEncoderPosition()+getRightEncoderPosition()/2.0);
    }

    public RelativeEncoder getLeftEncoder(){
        return m_encoderLeft;
    }

    public RelativeEncoder getRightEncoder(){
        return m_encoderRight;
    }

    public void setMaxOutput(double maxOutput){
        differentialDrive1.setMaxOutput(maxOutput);
    }

    public void zeroHeading(){
        m_Gyro.calibrate();
        m_Gyro.reset();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        m_odometry.update(Rotation2d.fromDegrees(m_Gyro.getAngle()), m_encoderLeft.getPosition(), m_encoderRight.getPosition());

        SmartDashboard.putNumber("Left encoder value meters", getLeftEncoderPosition());
        SmartDashboard.putNumber("Right encoder value meters", getRightEncoderPosition());
        SmartDashboard.putNumber("Left encoder velocity meters", getLeftEncoderVelocity());
        SmartDashboard.putNumber("Right encoder velocity meters", getRightEncoderVelocity());
        SmartDashboard.putNumber("Gyro two heading", m_Gyro.getAngle());

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void arcadeDrive(double power, double turnpower) {
        boolean squareInputsToReduceSenstivityAtLowSpeeds = true;
        differentialDrive1.arcadeDrive(power, turnpower, squareInputsToReduceSenstivityAtLowSpeeds);
    }
//    public void fieldOrientationDrive(double fieldAngle, double power ){
        
//    }
    public void tankDrive(double leftPower, double rightPower){
        differentialDrive1.tankDrive(leftPower, rightPower);
    }

    public RelativeEncoder getEncoderLeft(){
        return m_encoderLeft;
    };
    public RelativeEncoder getEncoderRight(){
        return m_encoderRight;
    };

    public Gyro getGyro(){
        return (Gyro) m_Gyro;
    }
    
    public ADIS16470_IMU getIMU(){
        return m_Gyro;
    }

}

